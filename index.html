<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Flumgus Caf√© </title>
<style>
  body, html {
    margin: 0; 
    padding: 0; 
    overflow: hidden;
    background: linear-gradient(135deg, #ff6b6b 0%, #feca57 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    height: 100vh;
    display: flex;
    flex-direction: column;
    touch-action: manipulation;
  }
  
  #gameContainer {
    flex: 1;
    position: relative;
    padding: 8px;
    padding-bottom: 4px;
    min-height: 200px;
  }
  
  #gameCanvas {
    background: linear-gradient(to bottom, #f8f9fa 0%, #e9ecef 100%);
    display: block;
    margin: 0 auto;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    width: 100%;
    height: 100%;
    max-height: 500px;
    touch-action: none;
    cursor: pointer;
  }
  
  #ui {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 12px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    user-select: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
    max-height: 40vh;
    overflow-y: auto;
  }
  
  #stats {
    display: flex;
    justify-content: center;
    gap: 16px;
    font-weight: 600;
    font-size: 16px;
    color: #2d3748;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }
  
  .stat-item {
    display: flex;
    align-items: center;
    gap: 6px;
    min-width: 120px;
    justify-content: center;
  }
  
  .stat-value {
    color: #e74c3c;
    font-weight: 700;
  }
  
  #gameInfo {
    text-align: center;
    margin-bottom: 8px;
    font-size: 14px;
    color: #2d3748;
  }
  
  #upgradeControls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 8px;
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
  }
  
  button {
    font-family: inherit;
    padding: 8px 12px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    border-radius: 8px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
  
  button:hover, button:active {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  .upgrade-btn {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
    text-align: left;
    position: relative;
    overflow: hidden;
    padding: 8px 12px;
    font-size: 11px;
  }
  
  .upgrade-btn:hover {
    background: linear-gradient(135deg, #c0392b, #a93226);
  }
  
  .upgrade-btn:disabled {
    background: #e2e8f0;
    color: #a0aec0;
    cursor: not-allowed;
    transform: none;
  }
  
  .upgrade-btn:disabled:hover {
    transform: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  #notification {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(52, 211, 153, 0.95);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: 600;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  
  @media (max-width: 768px) {
    #stats {
      font-size: 14px;
      gap: 12px;
    }
    
    .stat-item {
      min-width: 100px;
    }
    
    #upgradeControls {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
    
    .upgrade-btn {
      font-size: 10px;
      padding: 6px 8px;
    }
  }
  
  @media (max-width: 480px) {
    #gameContainer {
      padding: 4px;
    }
    
    #ui {
      padding: 8px;
    }
    
    #stats {
      font-size: 13px;
      gap: 8px;
    }
    
    .stat-item {
      min-width: 90px;
      font-size: 12px;
    }
    
    #upgradeControls {
      grid-template-columns: 1fr 1fr;
    }
    
    .upgrade-btn {
      font-size: 9px;
      padding: 6px;
    }
    
    button {
      font-size: 11px;
      padding: 6px 10px;
    }
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="notification"></div>
</div>

<div id="ui">
  <div id="stats">
    <div class="stat-item">
      <span>üí∞</span>
      <span>Money: $<span class="stat-value" id="money">0</span></span>
    </div>
    <div class="stat-item">
      <span>‚≠ê</span>
      <span>Rating: <span class="stat-value" id="rating">5.0</span>/5</span>
    </div>
    <div class="stat-item">
      <span>üìä</span>
      <span>Level: <span class="stat-value" id="level">1</span></span>
    </div>
  </div>
  
  <div id="gameInfo">
    Click stations to prepare orders! Keep customers happy to earn money and stars!
  </div>
  
  <div id="upgradeControls">
    <button class="upgrade-btn" id="speedUpBtn">‚ö° Faster Cooking<br><small>Cost: $<span id="speedCost">100</span></small></button>
    <button class="upgrade-btn" id="patienceUpBtn">üòå Customer Patience<br><small>Cost: $<span id="patienceCost">150</span></small></button>
    <button class="upgrade-btn" id="priceUpBtn">üíµ Menu Prices<br><small>Cost: $<span id="priceCost">200</span></small></button>
    <button class="upgrade-btn" id="qualityUpBtn">üë®‚Äçüç≥ Food Quality<br><small>Cost: $<span id="qualityCost">300</span></small></button>
    <button class="upgrade-btn" id="decorUpBtn">üé® Restaurant Decor<br><small>Cost: $<span id="decorCost">500</span></small></button>
    <button class="upgrade-btn" id="menuUpBtn">üìã Expand Menu<br><small>Cost: $<span id="menuCost">750</span></small></button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  
  const moneySpan = document.getElementById('money');
  const ratingSpan = document.getElementById('rating');
  const levelSpan = document.getElementById('level');
  const notification = document.getElementById('notification');
  
  // Game state
  let money = 50;
  let rating = 5.0;
  let level = 1;
  
  // Upgrades
  let cookingSpeed = 1;
  let customerPatience = 1;
  let menuPrices = 1;
  let foodQuality = 1;
  let decorLevel = 1;
  let menuVariety = 1;
  
  // Costs
  let speedCost = 100;
  let patienceCost = 150;
  let priceCost = 200;
  let qualityCost = 300;
  let decorCost = 500;
  let menuCost = 750;
  
  // Game objects
  let customers = [];
  let orders = [];
  let stations = [];
  let particles = [];
  
  // Game timing
  let customerSpawnTimer = 0;
  let gameTime = 0;
  let lastOrderId = 0;
  
  // Available dishes
  const dishes = [
    { name: 'Lettuce Salad', emoji: 'ü•ó', time: 2000, price: 8 },
    { name: 'Snail Soup', emoji: 'üç≤', time: 3000, price: 12 },
    { name: 'Garden Burger', emoji: 'üçî', time: 4000, price: 15 },
    { name: 'Veggie Pizza', emoji: 'üçï', time: 5000, price: 18 },
    { name: 'Pasta Special', emoji: 'üçù', time: 6000, price: 22 },
    { name: 'Gourmet Platter', emoji: 'üçΩÔ∏è', time: 8000, price: 30 }
  ];
  
  // Initialize stations
  function initStations() {
    stations = [
      { x: 100, y: 150, type: 'prep', emoji: 'üî™', name: 'Prep Station', busy: false, progress: 0, order: null },
      { x: 250, y: 150, type: 'grill', emoji: 'üî•', name: 'Grill', busy: false, progress: 0, order: null },
      { x: 400, y: 150, type: 'oven', emoji: 'üî•', name: 'Oven', busy: false, progress: 0, order: null },
      { x: 550, y: 150, type: 'plate', emoji: 'üçΩÔ∏è', name: 'Plating', busy: false, progress: 0, order: null }
    ];
  }
  
  // Resize canvas
  function resizeCanvas() {
    const container = document.getElementById('gameContainer');
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width - 16;
    canvas.height = Math.min(rect.height - 8, 500);
  }
  
  // Customer class
  class Customer {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.patience = 15000 + (customerPatience * 3000);
      this.maxPatience = this.patience;
      this.order = this.generateOrder();
      this.satisfied = false;
      this.angry = false;
      this.leaving = false;
      this.scale = 1;
      this.bounceTime = Math.random() * 1000;
    }
    
    generateOrder() {
      const availableDishes = dishes.slice(0, Math.min(dishes.length, 2 + menuVariety));
      return availableDishes[Math.floor(Math.random() * availableDishes.length)];
    }
    
    update(deltaTime) {
      this.bounceTime += deltaTime;
      this.scale = 1 + Math.sin(this.bounceTime * 0.003) * 0.1;
      
      if (!this.satisfied && !this.leaving) {
        this.patience -= deltaTime;
        if (this.patience <= 0) {
          this.angry = true;
          this.leaving = true;
          this.loseRating();
        }
      }
    }
    
    loseRating() {
      rating = Math.max(1.0, rating - 0.2);
      showNotification('Customer left angry! Rating decreased!', '#e74c3c');
    }
    
    serve() {
      this.satisfied = true;
      const basePrice = this.order.price * menuPrices;
      const qualityBonus = (foodQuality - 1) * 0.2 + 1;
      const decorBonus = (decorLevel - 1) * 0.1 + 1;
      const earnings = Math.floor(basePrice * qualityBonus * decorBonus);
      
      money += earnings;
      
      // Rating bonus for fast service
      const timeBonus = this.patience / this.maxPatience;
      if (timeBonus > 0.7) {
        rating = Math.min(5.0, rating + 0.1);
      }
      
      showNotification(`+$${earnings}! Customer happy!`, '#27ae60');
      
      // Particle effect
      for (let i = 0; i < 5; i++) {
        particles.push({
          x: this.x,
          y: this.y,
          vx: (Math.random() - 0.5) * 4,
          vy: -Math.random() * 3 - 1,
          life: 1000,
          maxLife: 1000,
          emoji: 'üí∞'
        });
      }
      
      setTimeout(() => this.leaving = true, 1000);
    }
    
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(this.scale, this.scale);
      
      // Customer
      ctx.font = '32px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (this.angry) {
        ctx.fillText('üò°', 0, 0);
      } else if (this.satisfied) {
        ctx.fillText('üòä', 0, 0);
      } else {
        ctx.fillText('üêå', 0, 0);
      }
      
      // Order bubble
      if (!this.satisfied && !this.leaving) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(-25, -60, 50, 30, 10);
        ctx.fill();
        ctx.stroke();
        
        ctx.font = '20px serif';
        ctx.fillStyle = '#333';
        ctx.fillText(this.order.emoji, 0, -45);
        
        // Patience bar
        const patiencePercent = this.patience / this.maxPatience;
        ctx.fillStyle = patiencePercent > 0.5 ? '#27ae60' : patiencePercent > 0.25 ? '#f39c12' : '#e74c3c';
        ctx.fillRect(-20, -25, 40 * patiencePercent, 4);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(-20, -25, 40, 4);
      }
      
      ctx.restore();
    }
  }
  
  // Order management
  function createOrder(dish, customer) {
    return {
      id: ++lastOrderId,
      dish: dish,
      customer: customer,
      stage: 0, // 0: prep, 1: cook, 2: plate, 3: serve
      progress: 0,
      station: null
    };
  }
  
  function findAvailableStation(type) {
    return stations.find(s => s.type === type && !s.busy);
  }
  
  function processOrder(order) {
    const stageTypes = ['prep', 'grill', 'plate'];
    const currentStage = stageTypes[order.stage];
    const station = findAvailableStation(currentStage);
    
    if (station) {
      station.busy = true;
      station.order = order;
      station.progress = 0;
      order.station = station;
      
      const cookTime = order.dish.time / cookingSpeed;
      
      setTimeout(() => {
        station.busy = false;
        station.progress = 0;
        order.stage++;
        
        if (order.stage >= 3) {
          // Order complete - serve customer
          order.customer.serve();
          orders = orders.filter(o => o.id !== order.id);
        } else {
          // Move to next stage
          order.station = null;
          processOrder(order);
        }
      }, cookTime);
    }
  }
  
  // Spawn customers
  function spawnCustomer() {
    const positions = [
      { x: 150, y: 300 },
      { x: 300, y: 320 },
      { x: 450, y: 300 },
      { x: 600, y: 320 }
    ];
    
    const availablePos = positions.filter(pos => 
      !customers.some(c => Math.abs(c.x - pos.x) < 50 && !c.leaving)
    );
    
    if (availablePos.length > 0) {
      const pos = availablePos[Math.floor(Math.random() * availablePos.length)];
      customers.push(new Customer(pos.x, pos.y));
    }
  }
// Food selection popup functionality
let foodSelectionPopup = null;

function showFoodSelectionPopup(x, y, callback) {
  // Remove existing popup if any
  hideFoodSelectionPopup();
  
  // Create popup container
  foodSelectionPopup = document.createElement('div');
  // ... (all the popup creation code)
}

function hideFoodSelectionPopup() {
  if (foodSelectionPopup) {
    foodSelectionPopup.remove();
    foodSelectionPopup = null;
  }
}
  // Handle clicks
 function handleClick(x, y) {
  // Check station clicks
  for (const station of stations) {
    const dx = x - station.x;
    const dy = y - station.y;
    if (Math.sqrt(dx * dx + dy * dy) < 40) {
      if (!station.busy && station.type === 'prep') {
        // Check if there are waiting customers
        const waitingCustomers = customers.filter(c => !c.satisfied && !c.leaving && 
          !orders.some(o => o.customer === c));
        
        if (waitingCustomers.length > 0) {
          // Show food selection popup
          const rect = canvas.getBoundingClientRect();
          const popupX = rect.left + station.x + 40;
          const popupY = rect.top + station.y - 20;
          
          showFoodSelectionPopup(popupX, popupY, (selectedDish) => {
            // Find a customer who wants this dish or assign to any waiting customer
            let targetCustomer = waitingCustomers.find(c => c.order.name === selectedDish.name);
            if (!targetCustomer) {
              targetCustomer = waitingCustomers[0]; // Just pick the first waiting customer
            }
            
            // Create order with selected dish
            const order = createOrder(selectedDish, targetCustomer);
            orders.push(order);
            processOrder(order);
          });
        } else {
          showNotification('No customers waiting!', '#f39c12');
        }
      }
      return;
    }
  }
  
  // Hide popup if clicking elsewhere
  hideFoodSelectionPopup();
}
  // Show notification
  function showNotification(text, color = '#27ae60') {
    notification.textContent = text;
    notification.style.backgroundColor = color;
    notification.style.opacity = '1';
    setTimeout(() => {
      notification.style.opacity = '0';
    }, 2000);
  }
  
  // Update game
  function update(deltaTime) {
    gameTime += deltaTime;
    
    // Spawn customers
    customerSpawnTimer += deltaTime;
    const spawnRate = Math.max(3000 - (level * 200), 1500);
    if (customerSpawnTimer >= spawnRate) {
      customerSpawnTimer = 0;
      if (customers.filter(c => !c.leaving).length < 4) {
        spawnCustomer();
      }
    }
    
    // Update customers
    customers.forEach(customer => customer.update(deltaTime));
    customers = customers.filter(customer => {
      if (customer.leaving && customer.satisfied) {
        return gameTime - customer.leaveTime < 1000;
      }
      return !customer.leaving || gameTime - customer.leaveTime < 500;
    });
    
    // Update particles
    particles.forEach(particle => {
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.vy += 0.1; // gravity
      particle.life -= deltaTime;
    });
    particles = particles.filter(p => p.life > 0);
    
    // Update station progress
    stations.forEach(station => {
      if (station.busy && station.order) {
        const cookTime = station.order.dish.time / cookingSpeed;
        station.progress = Math.min(1, (performance.now() - station.startTime) / cookTime);
      }
    });
    
    // Level up
    const targetLevel = Math.floor(money / 500) + 1;
    if (targetLevel > level) {
      level = targetLevel;
      showNotification(`Level ${level} reached!`, '#9b59b6');
    }
    
    updateUI();
  }
  
  // Draw game
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#f8f9fa');
    gradient.addColorStop(1, '#e9ecef');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Floor tiles
    ctx.fillStyle = '#dee2e6';
    for (let x = 0; x < canvas.width; x += 40) {
      for (let y = 0; y < canvas.height; y += 40) {
        if ((x/40 + y/40) % 2 === 0) {
          ctx.fillRect(x, y, 40, 40);
        }
      }
    }
    
    // Stations
    stations.forEach(station => {
      ctx.save();
      ctx.translate(station.x, station.y);
      
      // Station base
      ctx.fillStyle = station.busy ? '#e74c3c' : '#3498db';
      ctx.beginPath();
      ctx.roundRect(-30, -30, 60, 60, 10);
      ctx.fill();
      
      // Station emoji
      ctx.font = '32px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(station.emoji, 0, 0);
      
      // Progress bar
      if (station.busy) {
        ctx.fillStyle = '#27ae60';
        ctx.fillRect(-25, 35, 50 * station.progress, 5);
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 1;
        ctx.strokeRect(-25, 35, 50, 5);
      }
      
      // Station label
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#2c3e50';
      ctx.fillText(station.name, 0, 50);
      
      ctx.restore();
    });
    
    // Customers
    customers.forEach(customer => customer.draw());
    
    // Particles
    particles.forEach(particle => {
      ctx.save();
      ctx.globalAlpha = particle.life / particle.maxLife;
      ctx.font = '16px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(particle.emoji, particle.x, particle.y);
      ctx.restore();
    });
    
    // Instructions
    if (customers.length === 0 && orders.length === 0) {
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#7f8c8d';
      ctx.fillText('Click the Prep Station (üî™) when customers arrive to start cooking!', canvas.width/2, canvas.height - 30);
    }
  }
  
  // Update UI
  function updateUI() {
    moneySpan.textContent = money;
    ratingSpan.textContent = rating.toFixed(1);
    levelSpan.textContent = level;
    updateUpgradeButtons();
  }
  
  // Upgrade functions
  function updateUpgradeButtons() {
    document.getElementById('speedUpBtn').disabled = money < speedCost;
    document.getElementById('patienceUpBtn').disabled = money < patienceCost;
    document.getElementById('priceUpBtn').disabled = money < priceCost;
    document.getElementById('qualityUpBtn').disabled = money < qualityCost;
    document.getElementById('decorUpBtn').disabled = money < decorCost;
    document.getElementById('menuUpBtn').disabled = money < menuCost;
  }
  
  // Upgrade button handlers
  document.getElementById('speedUpBtn').onclick = () => {
    if (money >= speedCost) {
      money -= speedCost;
      cookingSpeed += 0.3;
      speedCost = Math.floor(speedCost * 1.5);
      document.getElementById('speedCost').textContent = speedCost;
      showNotification('Cooking speed increased!');
    }
  };
  
  document.getElementById('patienceUpBtn').onclick = () => {
    if (money >= patienceCost) {
      money -= patienceCost;
      customerPatience += 0.5;
      patienceCost = Math.floor(patienceCost * 1.5);
      document.getElementById('patienceCost').textContent = patienceCost;
      showNotification('Customer patience increased!');
    }
  };
  
  document.getElementById('priceUpBtn').onclick = () => {
    if (money >= priceCost) {
      money -= priceCost;
      menuPrices += 0.2;
      priceCost = Math.floor(priceCost * 1.5);
      document.getElementById('priceCost').textContent = priceCost;
      showNotification('Menu prices increased!');
    }
  };
  
  document.getElementById('qualityUpBtn').onclick = () => {
    if (money >= qualityCost) {
      money -= qualityCost;
      foodQuality += 0.3;
      qualityCost = Math.floor(qualityCost * 1.5);
      document.getElementById('qualityCost').textContent = qualityCost;
      showNotification('Food quality improved!');
    }
  };
  
  document.getElementById('decorUpBtn').onclick = () => {
    if (money >= decorCost) {
      money -= decorCost;
      decorLevel += 0.5;
      decorCost = Math.floor(decorCost * 1.5);
      document.getElementById('decorCost').textContent = decorCost;
      showNotification('Restaurant decor upgraded!');
    }
  };
  
  document.getElementById('menuUpBtn').onclick = () => {
    if (money >= menuCost) {
      money -= menuCost;
      menuVariety += 1;
      menuCost = Math.floor(menuCost * 1.5);
      document.getElementById('menuCost').textContent = menuCost;
      showNotification('Menu variety expanded!');
    }
  };
  
  // Event listeners
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    handleClick(x, y);
  });
  
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    handleClick(x, y);
  });
  
  window.addEventListener('resize', () => {
    setTimeout(resizeCanvas, 100);
  });
  
  // Game loop
  function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    update(deltaTime);
    draw();
    
    requestAnimationFrame(gameLoop);
  }
  
  // Initialize
  let lastTime;
  resizeCanvas();
  initStations();
  updateUI();
  requestAnimationFrame(gameLoop);
  
  // Add initial instructions
  setTimeout(() => {
    showNotification('Welcome to Flumgus Restaurant! Click prep station when customers arrive!', '#3498db');
  }, 1000);
})();
</script>

</body>
</html>
